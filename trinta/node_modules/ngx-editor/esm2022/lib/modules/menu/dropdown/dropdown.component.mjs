import { Component, HostListener, Input, } from '@angular/core';
import { ToggleCommands } from '../MenuCommands';
import * as i0 from "@angular/core";
import * as i1 from "../../../editor.service";
import * as i2 from "../menu.service";
import * as i3 from "@angular/common";
export class DropdownComponent {
    constructor(ngxeService, menuService, el) {
        this.ngxeService = ngxeService;
        this.menuService = menuService;
        this.el = el;
        this.isDropdownOpen = false;
        this.disabledItems = [];
        this.update = (view) => {
            const { state } = view;
            this.disabledItems = [];
            const activeItems = [];
            this.items.forEach((item) => {
                const command = ToggleCommands[item];
                const isActive = command.isActive(state);
                if (isActive) {
                    activeItems.push(item);
                }
                if (!command.canExecute(state)) {
                    this.disabledItems.push(item);
                }
            });
            if (activeItems.length === 1) {
                [this.activeItem] = activeItems;
            }
            else {
                this.activeItem = null;
            }
        };
    }
    get isSelected() {
        return Boolean(this.activeItem || this.isDropdownOpen);
    }
    get isDropdownDisabled() {
        return this.disabledItems.length === this.items.length;
    }
    onDocumentClick(target) {
        if (!this.el.nativeElement.contains(target) && this.isDropdownOpen) {
            this.isDropdownOpen = false;
        }
    }
    getName(key) {
        return this.ngxeService.locals.get(key);
    }
    toggleDropdown(e) {
        e.preventDefault();
        this.isDropdownOpen = !this.isDropdownOpen;
    }
    trackByIndex(index) {
        return index;
    }
    onClick(e, item) {
        e.preventDefault();
        // consider only left click
        if (e.button !== 0) {
            return;
        }
        const command = ToggleCommands[item];
        const { state, dispatch } = this.editorView;
        command.toggle()(state, dispatch);
        this.isDropdownOpen = false;
    }
    ngOnInit() {
        this.editorView = this.menuService.editor.view;
        this.updateSubscription = this.menuService.editor.update.subscribe((view) => {
            this.update(view);
        });
    }
    ngOnDestroy() {
        this.updateSubscription.unsubscribe();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.2", ngImport: i0, type: DropdownComponent, deps: [{ token: i1.NgxEditorService }, { token: i2.MenuService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.2", type: DropdownComponent, selector: "ngx-dropdown", inputs: { group: "group", items: "items" }, host: { listeners: { "document:mousedown": "onDocumentClick($event.target)" } }, ngImport: i0, template: "<div\n  class=\"NgxEditor__Dropdown--Text\"\n  [class.NgxEditor__Dropdown--Selected]=\"isSelected\"\n  [class.NgxEditor--Disabled]=\"isDropdownDisabled\"\n  (mousedown)=\"toggleDropdown($event)\"\n>\n  {{ getName(activeItem || group) | async }}\n</div>\n\n<div class=\"NgxEditor__Dropdown--DropdownMenu\" *ngIf=\"isDropdownOpen\">\n  <div\n    class=\"NgxEditor__Dropdown--Item\"\n    *ngFor=\"let item of items; trackBy: trackByIndex\"\n    (mousedown)=\"onClick($event, item)\"\n    [ngClass]=\"{\n      'NgxEditor__Dropdown--Active': item === activeItem,\n      'NgxEditor--Disabled': disabledItems.includes(item)\n    }\"\n  >\n    {{ getName(item) | async }}\n  </div>\n</div>\n", styles: [""], dependencies: [{ kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.2", ngImport: i0, type: DropdownComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngx-dropdown', template: "<div\n  class=\"NgxEditor__Dropdown--Text\"\n  [class.NgxEditor__Dropdown--Selected]=\"isSelected\"\n  [class.NgxEditor--Disabled]=\"isDropdownDisabled\"\n  (mousedown)=\"toggleDropdown($event)\"\n>\n  {{ getName(activeItem || group) | async }}\n</div>\n\n<div class=\"NgxEditor__Dropdown--DropdownMenu\" *ngIf=\"isDropdownOpen\">\n  <div\n    class=\"NgxEditor__Dropdown--Item\"\n    *ngFor=\"let item of items; trackBy: trackByIndex\"\n    (mousedown)=\"onClick($event, item)\"\n    [ngClass]=\"{\n      'NgxEditor__Dropdown--Active': item === activeItem,\n      'NgxEditor--Disabled': disabledItems.includes(item)\n    }\"\n  >\n    {{ getName(item) | async }}\n  </div>\n</div>\n" }]
        }], ctorParameters: () => [{ type: i1.NgxEditorService }, { type: i2.MenuService }, { type: i0.ElementRef }], propDecorators: { group: [{
                type: Input
            }], items: [{
                type: Input
            }], onDocumentClick: [{
                type: HostListener,
                args: ['document:mousedown', ['$event.target']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJvcGRvd24uY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LWVkaXRvci9zcmMvbGliL21vZHVsZXMvbWVudS9kcm9wZG93bi9kcm9wZG93bi5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtZWRpdG9yL3NyYy9saWIvbW9kdWxlcy9tZW51L2Ryb3Bkb3duL2Ryb3Bkb3duLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsWUFBWSxFQUFFLEtBQUssR0FDcEIsTUFBTSxlQUFlLENBQUM7QUFNdkIsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGlCQUFpQixDQUFDOzs7OztBQVFqRCxNQUFNLE9BQU8saUJBQWlCO0lBWTVCLFlBQ1UsV0FBNkIsRUFDN0IsV0FBd0IsRUFDeEIsRUFBYztRQUZkLGdCQUFXLEdBQVgsV0FBVyxDQUFrQjtRQUM3QixnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQUN4QixPQUFFLEdBQUYsRUFBRSxDQUFZO1FBUnhCLG1CQUFjLEdBQUcsS0FBSyxDQUFDO1FBRXZCLGtCQUFhLEdBQWEsRUFBRSxDQUFDO1FBa0RyQixXQUFNLEdBQUcsQ0FBQyxJQUFnQixFQUFFLEVBQUU7WUFDcEMsTUFBTSxFQUFFLEtBQUssRUFBRSxHQUFHLElBQUksQ0FBQztZQUN2QixJQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQztZQUN4QixNQUFNLFdBQVcsR0FBRyxFQUFFLENBQUM7WUFFdkIsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFvQixFQUFFLEVBQUU7Z0JBQzFDLE1BQU0sT0FBTyxHQUFHLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDckMsTUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztn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LEtBQUs7c0JBQWIsS0FBSztnQkFxQmlELGVBQWU7c0JBQXJFLFlBQVk7dUJBQUMsb0JBQW9CLEVBQUUsQ0FBQyxlQUFlLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb21wb25lbnQsIEVsZW1lbnRSZWYsXG4gIEhvc3RMaXN0ZW5lciwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdwcm9zZW1pcnJvci12aWV3JztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBOZ3hFZGl0b3JTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vZWRpdG9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgTWVudVNlcnZpY2UgfSBmcm9tICcuLi9tZW51LnNlcnZpY2UnO1xuaW1wb3J0IHsgVG9nZ2xlQ29tbWFuZHMgfSBmcm9tICcuLi9NZW51Q29tbWFuZHMnO1xuaW1wb3J0IHsgVEJIZWFkaW5nSXRlbXMgfSBmcm9tICcuLi8uLi8uLi90eXBlcyc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ25neC1kcm9wZG93bicsXG4gIHRlbXBsYXRlVXJsOiAnLi9kcm9wZG93bi5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL2Ryb3Bkb3duLmNvbXBvbmVudC5zY3NzJ10sXG59KVxuZXhwb3J0IGNsYXNzIERyb3Bkb3duQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIGVkaXRvclZpZXc6IEVkaXRvclZpZXc7XG4gIHByaXZhdGUgdXBkYXRlU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgQElucHV0KCkgZ3JvdXA6IHN0cmluZztcbiAgQElucHV0KCkgaXRlbXM6IFRCSGVhZGluZ0l0ZW1zW107XG5cbiAgaXNEcm9wZG93bk9wZW4gPSBmYWxzZTtcblxuICBkaXNhYmxlZEl0ZW1zOiBzdHJpbmdbXSA9IFtdO1xuICBhY3RpdmVJdGVtOiBzdHJpbmcgfCBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgbmd4ZVNlcnZpY2U6IE5neEVkaXRvclNlcnZpY2UsXG4gICAgcHJpdmF0ZSBtZW51U2VydmljZTogTWVudVNlcnZpY2UsXG4gICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZixcbiAgKSB7IH1cblxuICBnZXQgaXNTZWxlY3RlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmFjdGl2ZUl0ZW0gfHwgdGhpcy5pc0Ryb3Bkb3duT3Blbik7XG4gIH1cblxuICBnZXQgaXNEcm9wZG93bkRpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmRpc2FibGVkSXRlbXMubGVuZ3RoID09PSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2RvY3VtZW50Om1vdXNlZG93bicsIFsnJGV2ZW50LnRhcmdldCddKSBvbkRvY3VtZW50Q2xpY2sodGFyZ2V0OiBOb2RlKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY29udGFpbnModGFyZ2V0KSAmJiB0aGlzLmlzRHJvcGRvd25PcGVuKSB7XG4gICAgICB0aGlzLmlzRHJvcGRvd25PcGVuID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZ2V0TmFtZShrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMubmd4ZVNlcnZpY2UubG9jYWxzLmdldChrZXkpO1xuICB9XG5cbiAgdG9nZ2xlRHJvcGRvd24oZTogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmlzRHJvcGRvd25PcGVuID0gIXRoaXMuaXNEcm9wZG93bk9wZW47XG4gIH1cblxuICB0cmFja0J5SW5kZXgoaW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgb25DbGljayhlOiBNb3VzZUV2ZW50LCBpdGVtOiBUQkhlYWRpbmdJdGVtcyk6IHZvaWQge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIC8vIGNvbnNpZGVyIG9ubHkgbGVmdCBjbGlja1xuICAgIGlmIChlLmJ1dHRvbiAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbW1hbmQgPSBUb2dnbGVDb21tYW5kc1tpdGVtXTtcbiAgICBjb25zdCB7IHN0YXRlLCBkaXNwYXRjaCB9ID0gdGhpcy5lZGl0b3JWaWV3O1xuICAgIGNvbW1hbmQudG9nZ2xlKCkoc3RhdGUsIGRpc3BhdGNoKTtcbiAgICB0aGlzLmlzRHJvcGRvd25PcGVuID0gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZSA9ICh2aWV3OiBFZGl0b3JWaWV3KSA9PiB7XG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gdmlldztcbiAgICB0aGlzLmRpc2FibGVkSXRlbXMgPSBbXTtcbiAgICBjb25zdCBhY3RpdmVJdGVtcyA9IFtdO1xuXG4gICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtOiBUQkhlYWRpbmdJdGVtcykgPT4ge1xuICAgICAgY29uc3QgY29tbWFuZCA9IFRvZ2dsZUNvbW1hbmRzW2l0ZW1dO1xuICAgICAgY29uc3QgaXNBY3RpdmUgPSBjb21tYW5kLmlzQWN0aXZlKHN0YXRlKTtcblxuICAgICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgIGFjdGl2ZUl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghY29tbWFuZC5jYW5FeGVjdXRlKHN0YXRlKSkge1xuICAgICAgICB0aGlzLmRpc2FibGVkSXRlbXMucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChhY3RpdmVJdGVtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIFt0aGlzLmFjdGl2ZUl0ZW1dID0gYWN0aXZlSXRlbXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWN0aXZlSXRlbSA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIHRoaXMuZWRpdG9yVmlldyA9IHRoaXMubWVudVNlcnZpY2UuZWRpdG9yLnZpZXc7XG5cbiAgICB0aGlzLnVwZGF0ZVN1YnNjcmlwdGlvbiA9IHRoaXMubWVudVNlcnZpY2UuZWRpdG9yLnVwZGF0ZS5zdWJzY3JpYmUoKHZpZXc6IEVkaXRvclZpZXcpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlKHZpZXcpO1xuICAgIH0pO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy51cGRhdGVTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuIiwiPGRpdlxuICBjbGFzcz1cIk5neEVkaXRvcl9fRHJvcGRvd24tLVRleHRcIlxuICBbY2xhc3MuTmd4RWRpdG9yX19Ecm9wZG93bi0tU2VsZWN0ZWRdPVwiaXNTZWxlY3RlZFwiXG4gIFtjbGFzcy5OZ3hFZGl0b3ItLURpc2FibGVkXT1cImlzRHJvcGRvd25EaXNhYmxlZFwiXG4gIChtb3VzZWRvd24pPVwidG9nZ2xlRHJvcGRvd24oJGV2ZW50KVwiXG4+XG4gIHt7IGdldE5hbWUoYWN0aXZlSXRlbSB8fCBncm91cCkgfCBhc3luYyB9fVxuPC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJOZ3hFZGl0b3JfX0Ryb3Bkb3duLS1Ecm9wZG93bk1lbnVcIiAqbmdJZj1cImlzRHJvcGRvd25PcGVuXCI+XG4gIDxkaXZcbiAgICBjbGFzcz1cIk5neEVkaXRvcl9fRHJvcGRvd24tLUl0ZW1cIlxuICAgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zOyB0cmFja0J5OiB0cmFja0J5SW5kZXhcIlxuICAgIChtb3VzZWRvd24pPVwib25DbGljaygkZXZlbnQsIGl0ZW0pXCJcbiAgICBbbmdDbGFzc109XCJ7XG4gICAgICAnTmd4RWRpdG9yX19Ecm9wZG93bi0tQWN0aXZlJzogaXRlbSA9PT0gYWN0aXZlSXRlbSxcbiAgICAgICdOZ3hFZGl0b3ItLURpc2FibGVkJzogZGlzYWJsZWRJdGVtcy5pbmNsdWRlcyhpdGVtKVxuICAgIH1cIlxuICA+XG4gICAge3sgZ2V0TmFtZShpdGVtKSB8IGFzeW5jIH19XG4gIDwvZGl2PlxuPC9kaXY+XG4iXX0=