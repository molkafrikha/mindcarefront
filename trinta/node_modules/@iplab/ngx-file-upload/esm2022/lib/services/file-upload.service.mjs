import { Injectable } from '@angular/core';
import { FileUploadTypes } from './../helpers/file-types.class';
import { IsNullOrEmpty } from './../helpers/helpers.class';
import * as i0 from "@angular/core";
export class FileUploadService {
    constructor(renderer) {
        this.renderer = renderer;
        this.extensions = ['B', 'KB', 'MB', 'GB'];
        this.sizeRegex = new RegExp(`^(\\d+)(?:\\s{0,1})(${this.extensions.join('|')})?$`, 'i');
    }
    isFileDragDropAvailable() {
        const div = this.renderer.createElement('div');
        return (('draggable' in div) || ('ondragstart' in div && 'ondrop' in div));
    }
    parseSize(value) {
        if (IsNullOrEmpty(value)) {
            return 0;
        }
        if (typeof value === 'number') {
            return value;
        }
        const [, size, extension] = value.match(this.sizeRegex) || [null, '0', 'B'];
        const i = IsNullOrEmpty(extension) ? 0 : this.extensions.indexOf(extension.toUpperCase());
        return parseInt(size, 10) * Math.pow(1024, i < 0 ? 0 : i);
    }
    formatSize(size) {
        return this.calculateSize(size);
    }
    calculateSize(size, extensionIndex = 0) {
        if (isNaN(size)) {
            size = 0;
        }
        if (size < 1024) {
            return `${Math.round(size * 100) / 100} ${this.extensions[extensionIndex]}`;
        }
        return this.calculateSize(size / 1024, extensionIndex + 1);
    }
    getFileType(file) {
        return Object.keys(FileUploadTypes).find((key) => FileUploadTypes[key] === file.type);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.0", ngImport: i0, type: FileUploadService, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.0", ngImport: i0, type: FileUploadService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.0", ngImport: i0, type: FileUploadService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.Renderer2 }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZS11cGxvYWQuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lwbGFiL25neC1maWxlLXVwbG9hZC9zcmMvbGliL3NlcnZpY2VzL2ZpbGUtdXBsb2FkLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUN0RCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFDaEUsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLDRCQUE0QixDQUFDOztBQUszRCxNQUFNLE9BQU8saUJBQWlCO0lBTTFCLFlBQW9CLFFBQW1CO1FBQW5CLGFBQVEsR0FBUixRQUFRLENBQVc7UUFKdEIsZUFBVSxHQUFpQixDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRW5ELGNBQVMsR0FBRyxJQUFJLE1BQU0sQ0FBQyx1QkFBdUIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztJQUdwRyxDQUFDO0lBRU0sdUJBQXVCO1FBQzFCLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQy9DLE9BQU8sQ0FBQyxDQUFDLFdBQVcsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLGFBQWEsSUFBSSxHQUFHLElBQUksUUFBUSxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDL0UsQ0FBQztJQUVNLFNBQVMsQ0FBQyxLQUFzQjtRQUNuQyxJQUFJLGFBQWEsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN0QixPQUFPLENBQUMsQ0FBQztTQUNaO1FBRUQsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7WUFDM0IsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFFRCxNQUFNLENBQUMsRUFBRSxJQUFJLEVBQUUsU0FBUyxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQzVFLE1BQU0sQ0FBQyxHQUFJLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFXLENBQUMsQ0FBQztRQUVwRyxPQUFPLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM5RCxDQUFDO0lBRU0sVUFBVSxDQUFDLElBQVk7UUFDMUIsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFTyxhQUFhLENBQUMsSUFBWSxFQUFFLGlCQUF5QixDQUFDO1FBQzFELElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ2IsSUFBSSxHQUFHLENBQUMsQ0FBQztTQUNaO1FBRUQsSUFBSSxJQUFJLEdBQUcsSUFBSSxFQUFFO1lBQ2IsT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUM7U0FDL0U7UUFFRCxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxHQUFHLElBQUksRUFBRSxjQUFjLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDL0QsQ0FBQztJQUVNLFdBQVcsQ0FBQyxJQUFVO1FBQ3pCLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDMUYsQ0FBQzs4R0EvQ1EsaUJBQWlCO2tIQUFqQixpQkFBaUI7OzJGQUFqQixpQkFBaUI7a0JBRDdCLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgRmlsZVVwbG9hZFR5cGVzIH0gZnJvbSAnLi8uLi9oZWxwZXJzL2ZpbGUtdHlwZXMuY2xhc3MnO1xyXG5pbXBvcnQgeyBJc051bGxPckVtcHR5IH0gZnJvbSAnLi8uLi9oZWxwZXJzL2hlbHBlcnMuY2xhc3MnO1xyXG5cclxuZXhwb3J0IHR5cGUgSVNpemUgPSAnQicgfCAnS0InIHwgJ01CJyB8ICdHQic7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBGaWxlVXBsb2FkU2VydmljZSB7XHJcblxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBleHRlbnNpb25zOiBBcnJheTxJU2l6ZT4gPSBbJ0InLCAnS0InLCAnTUInLCAnR0InXTtcclxuXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNpemVSZWdleCA9IG5ldyBSZWdFeHAoYF4oXFxcXGQrKSg/OlxcXFxzezAsMX0pKCR7dGhpcy5leHRlbnNpb25zLmpvaW4oJ3wnKX0pPyRgLCAnaScpO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMikge1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpc0ZpbGVEcmFnRHJvcEF2YWlsYWJsZSgpOiBib29sZWFuIHtcclxuICAgICAgICBjb25zdCBkaXYgPSB0aGlzLnJlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHJldHVybiAoKCdkcmFnZ2FibGUnIGluIGRpdikgfHwgKCdvbmRyYWdzdGFydCcgaW4gZGl2ICYmICdvbmRyb3AnIGluIGRpdikpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBwYXJzZVNpemUodmFsdWU6IHN0cmluZyB8IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgaWYgKElzTnVsbE9yRW1wdHkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgWywgc2l6ZSwgZXh0ZW5zaW9uXSA9IHZhbHVlLm1hdGNoKHRoaXMuc2l6ZVJlZ2V4KSB8fCBbbnVsbCwgJzAnLCAnQiddO1xyXG4gICAgICAgIGNvbnN0IGkgPSAgSXNOdWxsT3JFbXB0eShleHRlbnNpb24pID8gMCA6IHRoaXMuZXh0ZW5zaW9ucy5pbmRleE9mKGV4dGVuc2lvbi50b1VwcGVyQ2FzZSgpIGFzIElTaXplKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHNpemUsIDEwKSAqIE1hdGgucG93KDEwMjQsIGkgPCAwID8gMCA6IGkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBmb3JtYXRTaXplKHNpemU6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlU2l6ZShzaXplKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNhbGN1bGF0ZVNpemUoc2l6ZTogbnVtYmVyLCBleHRlbnNpb25JbmRleDogbnVtYmVyID0gMCk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKGlzTmFOKHNpemUpKSB7XHJcbiAgICAgICAgICAgIHNpemUgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNpemUgPCAxMDI0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgJHtNYXRoLnJvdW5kKHNpemUgKiAxMDApIC8gMTAwfSAke3RoaXMuZXh0ZW5zaW9uc1tleHRlbnNpb25JbmRleF19YDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZVNpemUoc2l6ZSAvIDEwMjQsIGV4dGVuc2lvbkluZGV4ICsgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEZpbGVUeXBlKGZpbGU6IEZpbGUpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhGaWxlVXBsb2FkVHlwZXMpLmZpbmQoKGtleSkgPT4gRmlsZVVwbG9hZFR5cGVzW2tleV0gPT09IGZpbGUudHlwZSk7XHJcbiAgICB9XHJcbn1cclxuIl19