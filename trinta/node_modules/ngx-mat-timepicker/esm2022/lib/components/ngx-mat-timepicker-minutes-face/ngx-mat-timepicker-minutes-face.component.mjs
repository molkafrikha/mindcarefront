import { Component, EventEmitter, Input, Output } from "@angular/core";
import { NgxMatTimepickerUnits } from "../../models/ngx-mat-timepicker-units.enum";
import { NgxMatTimepickerUtils } from "../../utils/ngx-mat-timepicker.utils";
import { NgxMatTimepickerFaceComponent } from "../ngx-mat-timepicker-face/ngx-mat-timepicker-face.component";
import * as i0 from "@angular/core";
export class NgxMatTimepickerMinutesFaceComponent {
    set color(newValue) {
        this._color = newValue;
    }
    get color() {
        return this._color;
    }
    constructor() {
        this.minuteChange = new EventEmitter();
        this.minutesList = [];
        this.timeUnit = NgxMatTimepickerUnits;
        this._color = "primary";
    }
    ngOnChanges(changes) {
        // tslint:disable-next-line:no-string-literal
        if (changes["period"] && changes["period"].currentValue) {
            const minutes = NgxMatTimepickerUtils.getMinutes(this.minutesGap);
            this.minutesList = NgxMatTimepickerUtils.disableMinutes(minutes, this.selectedHour, {
                min: this.minTime,
                max: this.maxTime,
                format: this.format,
                period: this.period
            });
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: NgxMatTimepickerMinutesFaceComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.2.4", type: NgxMatTimepickerMinutesFaceComponent, isStandalone: true, selector: "ngx-mat-timepicker-minutes-face", inputs: { color: "color", dottedMinutesInGap: "dottedMinutesInGap", format: "format", maxTime: "maxTime", minTime: "minTime", minutesGap: "minutesGap", period: "period", selectedHour: "selectedHour", selectedMinute: "selectedMinute" }, outputs: { minuteChange: "minuteChange" }, usesOnChanges: true, ngImport: i0, template: "<ngx-mat-timepicker-face [color]=\"color\"\r\n\t\t\t\t\t\t [dottedMinutesInGap]=\"dottedMinutesInGap\"\r\n\t\t\t\t\t\t [faceTime]=\"minutesList\"\r\n\t\t\t\t\t\t [selectedTime]=\"selectedMinute\"\r\n\t\t\t\t\t\t [minutesGap]=\"minutesGap\"\r\n\t\t\t\t\t\t (timeChange)=\"minuteChange.next($event)\"\r\n\t\t\t\t\t\t [unit]=\"timeUnit.MINUTE\"></ngx-mat-timepicker-face>\r\n", dependencies: [{ kind: "component", type: NgxMatTimepickerFaceComponent, selector: "ngx-mat-timepicker-face", inputs: ["color", "dottedMinutesInGap", "faceTime", "format", "minutesGap", "selectedTime", "unit"], outputs: ["timeChange", "timeSelected"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: NgxMatTimepickerMinutesFaceComponent, decorators: [{
            type: Component,
            args: [{ selector: "ngx-mat-timepicker-minutes-face", standalone: true, imports: [NgxMatTimepickerFaceComponent], template: "<ngx-mat-timepicker-face [color]=\"color\"\r\n\t\t\t\t\t\t [dottedMinutesInGap]=\"dottedMinutesInGap\"\r\n\t\t\t\t\t\t [faceTime]=\"minutesList\"\r\n\t\t\t\t\t\t [selectedTime]=\"selectedMinute\"\r\n\t\t\t\t\t\t [minutesGap]=\"minutesGap\"\r\n\t\t\t\t\t\t (timeChange)=\"minuteChange.next($event)\"\r\n\t\t\t\t\t\t [unit]=\"timeUnit.MINUTE\"></ngx-mat-timepicker-face>\r\n" }]
        }], ctorParameters: () => [], propDecorators: { color: [{
                type: Input
            }], dottedMinutesInGap: [{
                type: Input
            }], format: [{
                type: Input
            }], maxTime: [{
                type: Input
            }], minTime: [{
                type: Input
            }], minuteChange: [{
                type: Output
            }], minutesGap: [{
                type: Input
            }], period: [{
                type: Input
            }], selectedHour: [{
                type: Input
            }], selectedMinute: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LW1hdC10aW1lcGlja2VyLW1pbnV0ZXMtZmFjZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtbWF0LXRpbWVwaWNrZXIvc3JjL2xpYi9jb21wb25lbnRzL25neC1tYXQtdGltZXBpY2tlci1taW51dGVzLWZhY2Uvbmd4LW1hdC10aW1lcGlja2VyLW1pbnV0ZXMtZmFjZS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtbWF0LXRpbWVwaWNrZXIvc3JjL2xpYi9jb21wb25lbnRzL25neC1tYXQtdGltZXBpY2tlci1taW51dGVzLWZhY2Uvbmd4LW1hdC10aW1lcGlja2VyLW1pbnV0ZXMtZmFjZS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsU0FBUyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQWEsTUFBTSxFQUFnQixNQUFNLGVBQWUsQ0FBQztBQUsvRixPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSw0Q0FBNEMsQ0FBQztBQUVqRixPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSxzQ0FBc0MsQ0FBQztBQUMzRSxPQUFPLEVBQUMsNkJBQTZCLEVBQUMsTUFBTSw4REFBOEQsQ0FBQzs7QUFVM0csTUFBTSxPQUFPLG9DQUFvQztJQUU3QyxJQUNJLEtBQUssQ0FBQyxRQUFzQjtRQUM1QixJQUFJLENBQUMsTUFBTSxHQUFHLFFBQVEsQ0FBQztJQUMzQixDQUFDO0lBRUQsSUFBSSxLQUFLO1FBQ0wsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQ3ZCLENBQUM7SUFtQkQ7UUFaVSxpQkFBWSxHQUFHLElBQUksWUFBWSxFQUE2QixDQUFDO1FBR3ZFLGdCQUFXLEdBQWdDLEVBQUUsQ0FBQztRQUs5QyxhQUFRLEdBQUcscUJBQXFCLENBQUM7UUFFekIsV0FBTSxHQUFpQixTQUFTLENBQUM7SUFHekMsQ0FBQztJQUVELFdBQVcsQ0FBQyxPQUFzQjtRQUM5Qiw2Q0FBNkM7UUFDN0MsSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLFlBQVksRUFBRTtZQUNyRCxNQUFNLE9BQU8sR0FBRyxxQkFBcUIsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ2xFLElBQUksQ0FBQyxXQUFXLEdBQUcscUJBQXFCLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsWUFBWSxFQUFFO2dCQUNoRixHQUFHLEVBQUUsSUFBSSxDQUFDLE9BQU87Z0JBQ2pCLEdBQUcsRUFBRSxJQUFJLENBQUMsT0FBTztnQkFDakIsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO2dCQUNuQixNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07YUFDdEIsQ0FBQyxDQUFDO1NBQ047SUFDTCxDQUFDOzhHQTFDUSxvQ0FBb0M7a0dBQXBDLG9DQUFvQyx1WUNsQmpELHNYQU9BLDRDRFNjLDZCQUE2Qjs7MkZBRTlCLG9DQUFvQztrQkFOaEQsU0FBUzsrQkFDSSxpQ0FBaUMsY0FFL0IsSUFBSSxXQUNQLENBQUMsNkJBQTZCLENBQUM7d0RBS3BDLEtBQUs7c0JBRFIsS0FBSztnQkFTRyxrQkFBa0I7c0JBQTFCLEtBQUs7Z0JBQ0csTUFBTTtzQkFBZCxLQUFLO2dCQUNHLE9BQU87c0JBQWYsS0FBSztnQkFDRyxPQUFPO3NCQUFmLEtBQUs7Z0JBRUksWUFBWTtzQkFBckIsTUFBTTtnQkFDRSxVQUFVO3NCQUFsQixLQUFLO2dCQUdHLE1BQU07c0JBQWQsS0FBSztnQkFDRyxZQUFZO3NCQUFwQixLQUFLO2dCQUVHLGNBQWM7c0JBQXRCLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25DaGFuZ2VzLCBPdXRwdXQsIFNpbXBsZUNoYW5nZXN9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XHJcbmltcG9ydCB7VGhlbWVQYWxldHRlfSBmcm9tIFwiQGFuZ3VsYXIvbWF0ZXJpYWwvY29yZVwiO1xyXG4vL1xyXG5pbXBvcnQge05neE1hdFRpbWVwaWNrZXJDbG9ja0ZhY2V9IGZyb20gXCIuLi8uLi9tb2RlbHMvbmd4LW1hdC10aW1lcGlja2VyLWNsb2NrLWZhY2UuaW50ZXJmYWNlXCI7XHJcbmltcG9ydCB7Tmd4TWF0VGltZXBpY2tlckZvcm1hdFR5cGV9IGZyb20gXCIuLi8uLi9tb2RlbHMvbmd4LW1hdC10aW1lcGlja2VyLWZvcm1hdC50eXBlXCI7XHJcbmltcG9ydCB7Tmd4TWF0VGltZXBpY2tlclVuaXRzfSBmcm9tIFwiLi4vLi4vbW9kZWxzL25neC1tYXQtdGltZXBpY2tlci11bml0cy5lbnVtXCI7XHJcbmltcG9ydCB7Tmd4TWF0VGltZXBpY2tlclBlcmlvZHN9IGZyb20gXCIuLi8uLi9tb2RlbHMvbmd4LW1hdC10aW1lcGlja2VyLXBlcmlvZHMuZW51bVwiO1xyXG5pbXBvcnQge05neE1hdFRpbWVwaWNrZXJVdGlsc30gZnJvbSBcIi4uLy4uL3V0aWxzL25neC1tYXQtdGltZXBpY2tlci51dGlsc1wiO1xyXG5pbXBvcnQge05neE1hdFRpbWVwaWNrZXJGYWNlQ29tcG9uZW50fSBmcm9tIFwiLi4vbmd4LW1hdC10aW1lcGlja2VyLWZhY2Uvbmd4LW1hdC10aW1lcGlja2VyLWZhY2UuY29tcG9uZW50XCI7XHJcbi8vXHJcbmltcG9ydCB7RGF0ZVRpbWV9IGZyb20gXCJ0cy1sdXhvblwiO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogXCJuZ3gtbWF0LXRpbWVwaWNrZXItbWludXRlcy1mYWNlXCIsXHJcbiAgICB0ZW1wbGF0ZVVybDogXCIuL25neC1tYXQtdGltZXBpY2tlci1taW51dGVzLWZhY2UuY29tcG9uZW50Lmh0bWxcIixcclxuICAgIHN0YW5kYWxvbmU6IHRydWUsXHJcbiAgICBpbXBvcnRzOiBbTmd4TWF0VGltZXBpY2tlckZhY2VDb21wb25lbnRdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBOZ3hNYXRUaW1lcGlja2VyTWludXRlc0ZhY2VDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBzZXQgY29sb3IobmV3VmFsdWU6IFRoZW1lUGFsZXR0ZSkge1xyXG4gICAgICAgIHRoaXMuX2NvbG9yID0gbmV3VmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGNvbG9yKCk6IFRoZW1lUGFsZXR0ZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yO1xyXG4gICAgfVxyXG5cclxuICAgIEBJbnB1dCgpIGRvdHRlZE1pbnV0ZXNJbkdhcDogYm9vbGVhbjtcclxuICAgIEBJbnB1dCgpIGZvcm1hdDogTmd4TWF0VGltZXBpY2tlckZvcm1hdFR5cGU7XHJcbiAgICBASW5wdXQoKSBtYXhUaW1lOiBEYXRlVGltZTtcclxuICAgIEBJbnB1dCgpIG1pblRpbWU6IERhdGVUaW1lO1xyXG5cclxuICAgIEBPdXRwdXQoKSBtaW51dGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPE5neE1hdFRpbWVwaWNrZXJDbG9ja0ZhY2U+KCk7XHJcbiAgICBASW5wdXQoKSBtaW51dGVzR2FwOiBudW1iZXI7XHJcblxyXG4gICAgbWludXRlc0xpc3Q6IE5neE1hdFRpbWVwaWNrZXJDbG9ja0ZhY2VbXSA9IFtdO1xyXG4gICAgQElucHV0KCkgcGVyaW9kOiBOZ3hNYXRUaW1lcGlja2VyUGVyaW9kcztcclxuICAgIEBJbnB1dCgpIHNlbGVjdGVkSG91cjogbnVtYmVyO1xyXG5cclxuICAgIEBJbnB1dCgpIHNlbGVjdGVkTWludXRlOiBOZ3hNYXRUaW1lcGlja2VyQ2xvY2tGYWNlO1xyXG4gICAgdGltZVVuaXQgPSBOZ3hNYXRUaW1lcGlja2VyVW5pdHM7XHJcblxyXG4gICAgcHJpdmF0ZSBfY29sb3I6IFRoZW1lUGFsZXR0ZSA9IFwicHJpbWFyeVwiO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tc3RyaW5nLWxpdGVyYWxcclxuICAgICAgICBpZiAoY2hhbmdlc1tcInBlcmlvZFwiXSAmJiBjaGFuZ2VzW1wicGVyaW9kXCJdLmN1cnJlbnRWYWx1ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBtaW51dGVzID0gTmd4TWF0VGltZXBpY2tlclV0aWxzLmdldE1pbnV0ZXModGhpcy5taW51dGVzR2FwKTtcclxuICAgICAgICAgICAgdGhpcy5taW51dGVzTGlzdCA9IE5neE1hdFRpbWVwaWNrZXJVdGlscy5kaXNhYmxlTWludXRlcyhtaW51dGVzLCB0aGlzLnNlbGVjdGVkSG91ciwge1xyXG4gICAgICAgICAgICAgICAgbWluOiB0aGlzLm1pblRpbWUsXHJcbiAgICAgICAgICAgICAgICBtYXg6IHRoaXMubWF4VGltZSxcclxuICAgICAgICAgICAgICAgIGZvcm1hdDogdGhpcy5mb3JtYXQsXHJcbiAgICAgICAgICAgICAgICBwZXJpb2Q6IHRoaXMucGVyaW9kXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuIiwiPG5neC1tYXQtdGltZXBpY2tlci1mYWNlIFtjb2xvcl09XCJjb2xvclwiXHJcblx0XHRcdFx0XHRcdCBbZG90dGVkTWludXRlc0luR2FwXT1cImRvdHRlZE1pbnV0ZXNJbkdhcFwiXHJcblx0XHRcdFx0XHRcdCBbZmFjZVRpbWVdPVwibWludXRlc0xpc3RcIlxyXG5cdFx0XHRcdFx0XHQgW3NlbGVjdGVkVGltZV09XCJzZWxlY3RlZE1pbnV0ZVwiXHJcblx0XHRcdFx0XHRcdCBbbWludXRlc0dhcF09XCJtaW51dGVzR2FwXCJcclxuXHRcdFx0XHRcdFx0ICh0aW1lQ2hhbmdlKT1cIm1pbnV0ZUNoYW5nZS5uZXh0KCRldmVudClcIlxyXG5cdFx0XHRcdFx0XHQgW3VuaXRdPVwidGltZVVuaXQuTUlOVVRFXCI+PC9uZ3gtbWF0LXRpbWVwaWNrZXItZmFjZT5cclxuIl19