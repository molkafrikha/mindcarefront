import { Directive, inject, effect } from '@angular/core';
import { of, fromEvent, map, takeUntil, tap, switchMap } from 'rxjs';
import { stopPropagation, enableSelection, preventSelection } from '../utils/common';
import { ScrollbarManager } from '../utils/scrollbar-manager';
import { TrackAdapter } from '../track/track-adapter';
import { PointerEventsAdapter } from '../utils/pointer-events-adapter';
import * as i0 from "@angular/core";
export class ThumbAdapter extends PointerEventsAdapter {
    // Returns thumb size
    get size() {
        return this.nativeElement[this.control.sizeProperty];
    }
    // The maximum space available for scrolling.
    get trackMax() {
        return this.track.size - this.size;
    }
    /**
     * Stream that emits the 'scrollTo' position when a scrollbar thumb element is dragged
     * This function is called by thumb drag event using viewport or scrollbar pointer events
     */
    get pointerEvents() {
        return fromEvent(this.nativeElement, 'pointerdown').pipe(stopPropagation(), preventSelection(this.document), switchMap((e) => {
            let startTrackMax;
            let startScrollMax;
            const dragStart = of(e).pipe(tap(() => {
                // Capture scrollMax and trackMax once
                startTrackMax = this.trackMax;
                startScrollMax = this.control.viewportScrollMax;
                this.setDragging(this.control.axis);
            }));
            const dragging = fromEvent(this.document, 'pointermove').pipe(stopPropagation());
            const dragEnd = fromEvent(this.document, 'pointerup', { capture: true }).pipe(stopPropagation(), enableSelection(this.document), tap(() => this.setDragging('none')));
            return dragStart.pipe(map((startEvent) => startEvent[this.control.offsetProperty]), switchMap((startOffset) => dragging.pipe(map((moveEvent) => moveEvent[this.control.clientProperty]), 
            // Calculate how far the pointer is from the top/left of the scrollbar (minus the dragOffset).
            map((moveClient) => moveClient - this.track.offset), map((trackRelativeOffset) => startScrollMax * (trackRelativeOffset - startOffset) / startTrackMax), tap((scrollPosition) => this.control.instantScrollTo(scrollPosition, startScrollMax)), takeUntil(dragEnd))));
        }));
    }
    constructor() {
        effect(() => {
            const script = this.manager.scrollTimelinePolyfill();
            if (script && !this._animation) {
                this._animation = startPolyfill(script, this.nativeElement, this.cmp.viewport.nativeElement, this.control.axis);
            }
        });
        super();
        this.manager = inject(ScrollbarManager);
        this.track = inject(TrackAdapter);
    }
    setDragging(value) {
        this.zone.run(() => this.cmp.dragging.set(value));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: ThumbAdapter, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.3", type: ThumbAdapter, usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.3", ngImport: i0, type: ThumbAdapter, decorators: [{
            type: Directive
        }], ctorParameters: () => [] });
function startPolyfill(ScrollTimeline, element, source, axis) {
    return element.animate({
        translate: [
            'var(--_scrollbar-thumb-transform-from)',
            'var(--_scrollbar-thumb-transform-to)'
        ]
    }, {
        fill: 'both',
        easing: 'linear',
        timeline: new ScrollTimeline({ source, axis })
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGh1bWItYWRhcHRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1zY3JvbGxiYXIvc3JjL2xpYi90aHVtYi90aHVtYi1hZGFwdGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMxRCxPQUFPLEVBQWMsRUFBRSxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDakYsT0FBTyxFQUdMLGVBQWUsRUFDZixlQUFlLEVBQ2YsZ0JBQWdCLEVBQ2pCLE1BQU0saUJBQWlCLENBQUM7QUFDekIsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDOUQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3RELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGlDQUFpQyxDQUFDOztBQUd2RSxNQUFNLE9BQWdCLFlBQWEsU0FBUSxvQkFBb0I7SUFTN0QscUJBQXFCO0lBQ3JCLElBQUksSUFBSTtRQUNOLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRCw2Q0FBNkM7SUFDN0MsSUFBSSxRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxJQUFJLGFBQWE7UUFDZixPQUFPLFNBQVMsQ0FBZSxJQUFJLENBQUMsYUFBYSxFQUFFLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FDcEUsZUFBZSxFQUFFLEVBQ2pCLGdCQUFnQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsRUFDL0IsU0FB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UUFBUSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3BELENBQUM7OEdBM0VtQixZQUFZO2tHQUFaLFlBQVk7OzJGQUFaLFlBQVk7a0JBRGpDLFNBQVM7O0FBK0VWLFNBQVMsYUFBYSxDQUFDLGNBQWtDLEVBQUUsT0FBb0IsRUFBRSxNQUFtQixFQUFFLElBQWU7SUFDbkgsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUNwQjtRQUNFLFNBQVMsRUFBRTtZQUNULHdDQUF3QztZQUN4QyxzQ0FBc0M7U0FDdkM7S0FDRixFQUNEO1FBQ0UsSUFBSSxFQUFFLE1BQU07UUFDWixNQUFNLEVBQUUsUUFBUTtRQUNoQixRQUFRLEVBQUUsSUFBSSxjQUFjLENBQUMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUM7S0FDcEMsQ0FDYixDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgaW5qZWN0LCBlZmZlY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YsIGZyb21FdmVudCwgbWFwLCB0YWtlVW50aWwsIHRhcCwgc3dpdGNoTWFwIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7XHJcbiAgU2Nyb2xsYmFyRHJhZ2dpbmcsXHJcbiAgU2Nyb2xsVGltZWxpbmVGdW5jLFxyXG4gIHN0b3BQcm9wYWdhdGlvbixcclxuICBlbmFibGVTZWxlY3Rpb24sXHJcbiAgcHJldmVudFNlbGVjdGlvblxyXG59IGZyb20gJy4uL3V0aWxzL2NvbW1vbic7XHJcbmltcG9ydCB7IFNjcm9sbGJhck1hbmFnZXIgfSBmcm9tICcuLi91dGlscy9zY3JvbGxiYXItbWFuYWdlcic7XHJcbmltcG9ydCB7IFRyYWNrQWRhcHRlciB9IGZyb20gJy4uL3RyYWNrL3RyYWNrLWFkYXB0ZXInO1xyXG5pbXBvcnQgeyBQb2ludGVyRXZlbnRzQWRhcHRlciB9IGZyb20gJy4uL3V0aWxzL3BvaW50ZXItZXZlbnRzLWFkYXB0ZXInO1xyXG5cclxuQERpcmVjdGl2ZSgpXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUaHVtYkFkYXB0ZXIgZXh0ZW5kcyBQb2ludGVyRXZlbnRzQWRhcHRlciB7XHJcblxyXG4gIHByb3RlY3RlZCByZWFkb25seSBtYW5hZ2VyOiBTY3JvbGxiYXJNYW5hZ2VyID0gaW5qZWN0KFNjcm9sbGJhck1hbmFnZXIpO1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IHRyYWNrOiBUcmFja0FkYXB0ZXIgPSBpbmplY3QoVHJhY2tBZGFwdGVyKTtcclxuXHJcbiAgLy8gVGhlIGFuaW1hdGlvbiByZWZlcmVuY2UgdXNlZCBmb3IgZW5hYmxpbmcgdGhlIHBvbHlmaWxsIG9uIFNhZmFyaSBhbmQgRmlyZWZveC5cclxuICBfYW5pbWF0aW9uOiBBbmltYXRpb247XHJcblxyXG4gIC8vIFJldHVybnMgdGh1bWIgc2l6ZVxyXG4gIGdldCBzaXplKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5uYXRpdmVFbGVtZW50W3RoaXMuY29udHJvbC5zaXplUHJvcGVydHldO1xyXG4gIH1cclxuXHJcbiAgLy8gVGhlIG1heGltdW0gc3BhY2UgYXZhaWxhYmxlIGZvciBzY3JvbGxpbmcuXHJcbiAgZ2V0IHRyYWNrTWF4KCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFjay5zaXplIC0gdGhpcy5zaXplO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RyZWFtIHRoYXQgZW1pdHMgdGhlICdzY3JvbGxUbycgcG9zaXRpb24gd2hlbiBhIHNjcm9sbGJhciB0aHVtYiBlbGVtZW50IGlzIGRyYWdnZWRcclxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSB0aHVtYiBkcmFnIGV2ZW50IHVzaW5nIHZpZXdwb3J0IG9yIHNjcm9sbGJhciBwb2ludGVyIGV2ZW50c1xyXG4gICAqL1xyXG4gIGdldCBwb2ludGVyRXZlbnRzKCk6IE9ic2VydmFibGU8UG9pbnRlckV2ZW50PiB7XHJcbiAgICByZXR1cm4gZnJvbUV2ZW50PFBvaW50ZXJFdmVudD4odGhpcy5uYXRpdmVFbGVtZW50LCAncG9pbnRlcmRvd24nKS5waXBlKFxyXG4gICAgICBzdG9wUHJvcGFnYXRpb24oKSxcclxuICAgICAgcHJldmVudFNlbGVjdGlvbih0aGlzLmRvY3VtZW50KSxcclxuICAgICAgc3dpdGNoTWFwKChlOiBQb2ludGVyRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgc3RhcnRUcmFja01heDogbnVtYmVyO1xyXG4gICAgICAgIGxldCBzdGFydFNjcm9sbE1heDogbnVtYmVyO1xyXG5cclxuICAgICAgICBjb25zdCBkcmFnU3RhcnQ6IE9ic2VydmFibGU8UG9pbnRlckV2ZW50PiA9IG9mPFBvaW50ZXJFdmVudD4oZSkucGlwZShcclxuICAgICAgICAgIHRhcCgoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIENhcHR1cmUgc2Nyb2xsTWF4IGFuZCB0cmFja01heCBvbmNlXHJcbiAgICAgICAgICAgIHN0YXJ0VHJhY2tNYXggPSB0aGlzLnRyYWNrTWF4O1xyXG4gICAgICAgICAgICBzdGFydFNjcm9sbE1heCA9IHRoaXMuY29udHJvbC52aWV3cG9ydFNjcm9sbE1heDtcclxuICAgICAgICAgICAgdGhpcy5zZXREcmFnZ2luZyh0aGlzLmNvbnRyb2wuYXhpcyk7XHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjb25zdCBkcmFnZ2luZzogT2JzZXJ2YWJsZTxQb2ludGVyRXZlbnQ+ID0gZnJvbUV2ZW50PFBvaW50ZXJFdmVudD4odGhpcy5kb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJykucGlwZShzdG9wUHJvcGFnYXRpb24oKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGRyYWdFbmQ6IE9ic2VydmFibGU8UG9pbnRlckV2ZW50PiA9IGZyb21FdmVudDxQb2ludGVyRXZlbnQ+KHRoaXMuZG9jdW1lbnQsICdwb2ludGVydXAnLCB7IGNhcHR1cmU6IHRydWUgfSkucGlwZShcclxuICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbigpLFxyXG4gICAgICAgICAgZW5hYmxlU2VsZWN0aW9uKHRoaXMuZG9jdW1lbnQpLFxyXG4gICAgICAgICAgdGFwKCgpID0+IHRoaXMuc2V0RHJhZ2dpbmcoJ25vbmUnKSlcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gZHJhZ1N0YXJ0LnBpcGUoXHJcbiAgICAgICAgICBtYXAoKHN0YXJ0RXZlbnQ6IFBvaW50ZXJFdmVudCkgPT4gc3RhcnRFdmVudFt0aGlzLmNvbnRyb2wub2Zmc2V0UHJvcGVydHldKSxcclxuICAgICAgICAgIHN3aXRjaE1hcCgoc3RhcnRPZmZzZXQ6IG51bWJlcikgPT4gZHJhZ2dpbmcucGlwZShcclxuICAgICAgICAgICAgbWFwKChtb3ZlRXZlbnQ6IFBvaW50ZXJFdmVudCkgPT4gbW92ZUV2ZW50W3RoaXMuY29udHJvbC5jbGllbnRQcm9wZXJ0eV0pLFxyXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgaG93IGZhciB0aGUgcG9pbnRlciBpcyBmcm9tIHRoZSB0b3AvbGVmdCBvZiB0aGUgc2Nyb2xsYmFyIChtaW51cyB0aGUgZHJhZ09mZnNldCkuXHJcbiAgICAgICAgICAgIG1hcCgobW92ZUNsaWVudDogbnVtYmVyKSA9PiBtb3ZlQ2xpZW50IC0gdGhpcy50cmFjay5vZmZzZXQpLFxyXG4gICAgICAgICAgICBtYXAoKHRyYWNrUmVsYXRpdmVPZmZzZXQ6IG51bWJlcikgPT4gc3RhcnRTY3JvbGxNYXggKiAodHJhY2tSZWxhdGl2ZU9mZnNldCAtIHN0YXJ0T2Zmc2V0KSAvIHN0YXJ0VHJhY2tNYXgpLFxyXG4gICAgICAgICAgICB0YXAoKHNjcm9sbFBvc2l0aW9uOiBudW1iZXIpID0+IHRoaXMuY29udHJvbC5pbnN0YW50U2Nyb2xsVG8oc2Nyb2xsUG9zaXRpb24sIHN0YXJ0U2Nyb2xsTWF4KSksXHJcbiAgICAgICAgICAgIHRha2VVbnRpbChkcmFnRW5kKVxyXG4gICAgICAgICAgKSBhcyBPYnNlcnZhYmxlPFBvaW50ZXJFdmVudD4pXHJcbiAgICAgICAgKTtcclxuICAgICAgfSlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIGVmZmVjdCgoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHNjcmlwdDogU2Nyb2xsVGltZWxpbmVGdW5jID0gdGhpcy5tYW5hZ2VyLnNjcm9sbFRpbWVsaW5lUG9seWZpbGwoKTtcclxuICAgICAgaWYgKHNjcmlwdCAmJiAhdGhpcy5fYW5pbWF0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uID0gc3RhcnRQb2x5ZmlsbChzY3JpcHQsIHRoaXMubmF0aXZlRWxlbWVudCwgdGhpcy5jbXAudmlld3BvcnQubmF0aXZlRWxlbWVudCwgdGhpcy5jb250cm9sLmF4aXMpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHN1cGVyKCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHNldERyYWdnaW5nKHZhbHVlOiBTY3JvbGxiYXJEcmFnZ2luZyk6IHZvaWQge1xyXG4gICAgdGhpcy56b25lLnJ1bigoKSA9PiB0aGlzLmNtcC5kcmFnZ2luZy5zZXQodmFsdWUpKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0YXJ0UG9seWZpbGwoU2Nyb2xsVGltZWxpbmU6IFNjcm9sbFRpbWVsaW5lRnVuYywgZWxlbWVudDogSFRNTEVsZW1lbnQsIHNvdXJjZTogSFRNTEVsZW1lbnQsIGF4aXM6ICd4JyB8ICd5Jyk6IEFuaW1hdGlvbiB7XHJcbiAgcmV0dXJuIGVsZW1lbnQuYW5pbWF0ZShcclxuICAgIHtcclxuICAgICAgdHJhbnNsYXRlOiBbXHJcbiAgICAgICAgJ3ZhcigtLV9zY3JvbGxiYXItdGh1bWItdHJhbnNmb3JtLWZyb20pJyxcclxuICAgICAgICAndmFyKC0tX3Njcm9sbGJhci10aHVtYi10cmFuc2Zvcm0tdG8pJ1xyXG4gICAgICBdXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBmaWxsOiAnYm90aCcsXHJcbiAgICAgIGVhc2luZzogJ2xpbmVhcicsXHJcbiAgICAgIHRpbWVsaW5lOiBuZXcgU2Nyb2xsVGltZWxpbmUoeyBzb3VyY2UsIGF4aXMgfSlcclxuICAgIH0gYXMgdW5rbm93blxyXG4gICk7XHJcbn1cclxuIl19