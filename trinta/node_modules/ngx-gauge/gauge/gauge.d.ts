import { SimpleChanges, Renderer2, AfterViewInit, ElementRef, OnChanges, OnDestroy, OnInit } from '@angular/core';
import { NgxGaugeLabel, NgxGaugeValue, NgxGaugePrepend, NgxGaugeAppend } from './gauge-directives';
import * as i0 from "@angular/core";
export type NgxGaugeType = 'full' | 'arch' | 'semi';
export type NgxGaugeCap = 'round' | 'butt';
export declare class NgxGauge implements AfterViewInit, OnChanges, OnDestroy, OnInit {
    private _elementRef;
    private _renderer;
    _canvas: ElementRef;
    _label: ElementRef;
    _reading: ElementRef;
    _labelChild: NgxGaugeLabel;
    _prependChild: NgxGaugePrepend;
    _appendChild: NgxGaugeAppend;
    _valueDisplayChild: NgxGaugeValue;
    private _size;
    private _min;
    private _max;
    private _animate;
    private _margin;
    private _initialized;
    private _context;
    private _animationRequestID;
    ariaLabel: string;
    ariaLabelledby: string | null;
    get size(): number;
    set size(value: number);
    get margin(): number;
    set margin(value: number);
    get min(): number;
    set min(value: number);
    get animate(): boolean;
    set animate(value: boolean);
    get max(): number;
    set max(value: number);
    type: NgxGaugeType;
    cap: NgxGaugeCap;
    thick: number;
    label: string;
    append: string;
    prepend: string;
    foregroundColor: string;
    backgroundColor: string;
    thresholds: Object;
    markers: Object;
    private _value;
    get value(): number;
    set value(val: number);
    duration: number;
    /** keep track of previous value in case of negative numbers or mistypes */
    private _oldChangeVal;
    constructor(_elementRef: ElementRef, _renderer: Renderer2);
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    private _updateSize;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    private _getBounds;
    private _drawShell;
    private _drawFill;
    private _addMarker;
    private _clear;
    private _getWidth;
    private _getHeight;
    private _getCanvasHeight;
    private _getRadius;
    private _getCenter;
    private _init;
    private _destroy;
    private _getForegroundColorByRange;
    private _getThresholdMatchForValue;
    private _getNextThreshold;
    private _getBackgroundColorRanges;
    private _getDisplacement;
    private _create;
    private _drawMarkersAndTicks;
    private _update;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxGauge, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<NgxGauge, "ngx-gauge", never, { "ariaLabel": { "alias": "aria-label"; "required": false; }; "ariaLabelledby": { "alias": "aria-labelledby"; "required": false; }; "size": { "alias": "size"; "required": false; }; "margin": { "alias": "margin"; "required": false; }; "min": { "alias": "min"; "required": false; }; "animate": { "alias": "animate"; "required": false; }; "max": { "alias": "max"; "required": false; }; "type": { "alias": "type"; "required": false; }; "cap": { "alias": "cap"; "required": false; }; "thick": { "alias": "thick"; "required": false; }; "label": { "alias": "label"; "required": false; }; "append": { "alias": "append"; "required": false; }; "prepend": { "alias": "prepend"; "required": false; }; "foregroundColor": { "alias": "foregroundColor"; "required": false; }; "backgroundColor": { "alias": "backgroundColor"; "required": false; }; "thresholds": { "alias": "thresholds"; "required": false; }; "markers": { "alias": "markers"; "required": false; }; "value": { "alias": "value"; "required": false; }; "duration": { "alias": "duration"; "required": false; }; }, {}, ["_labelChild", "_prependChild", "_appendChild", "_valueDisplayChild"], ["ngx-gauge-prepend", "ngx-gauge-value", "ngx-gauge-append", "ngx-gauge-label"], false, never>;
}
